"""
Chat endpoints for conversation management and AI responses.

Generated on: 2024-12-19T10:30:00Z
Generated by syed
"""

from datetime import datetime, timezone
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel

from app.core.auth import get_current_active_user
from app.core.database import get_db
from app.models.user import User
from app.models.conversation import Conversation, Message, ConversationType, MessageRole
from app.services.rag_service import rag_service
import structlog

logger = structlog.get_logger()
router = APIRouter()


class ChatMessage(BaseModel):
    """Chat message request model."""
    content: str
    conversation_id: Optional[int] = None
    conversation_type: ConversationType = ConversationType.CUSTOMER_SUPPORT


class ChatResponse(BaseModel):
    """Chat response model."""
    message_id: int
    content: str
    role: str
    conversation_id: int
    sources: List[dict] = []
    confidence_score: int = 0
    model_used: str = ""
    timestamp: str = ""


class ConversationResponse(BaseModel):
    """Conversation response model."""
    id: int
    title: Optional[str]
    conversation_type: ConversationType
    message_count: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


class MessageResponse(BaseModel):
    """Message response model."""
    id: int
    content: str
    role: str
    conversation_id: int
    sources: Optional[List[dict]]
    confidence_score: Optional[int]
    model_used: Optional[str]
    created_at: datetime
    
    class Config:
        from_attributes = True


@router.post("/send", response_model=ChatResponse)
async def send_message(
    message: ChatMessage,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """Send a message and get AI response."""
    try:
        # Get or create conversation
        if message.conversation_id:
            result = await db.execute(
                select(Conversation).where(
                    Conversation.id == message.conversation_id,
                    Conversation.user_id == current_user.id
                )
            )
            conversation = result.scalar_one_or_none()
            if not conversation:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Conversation not found"
                )
        else:
            # Create new conversation
            conversation = Conversation(
                user_id=current_user.id,
                conversation_type=message.conversation_type,
                title=message.content[:50] + "..." if len(message.content) > 50 else message.content
            )
            db.add(conversation)
            await db.commit()
            await db.refresh(conversation)
        
        # Save user message
        user_message = Message(
            conversation_id=conversation.id,
            role=MessageRole.USER,
            content=message.content
        )
        db.add(user_message)
        await db.commit()
        await db.refresh(user_message)
        
        # Get AI response
        start_time = datetime.now(timezone.utc)
        rag_response = await rag_service.get_response(
            question=message.content,
            user_role=current_user.role.value
        )
        response_time = int((datetime.now(timezone.utc) - start_time).total_seconds() * 1000)
        
        # Save AI response
        ai_message = Message(
            conversation_id=conversation.id,
            role=MessageRole.ASSISTANT,
            content=rag_response["answer"],
            tokens_used=rag_response.get("tokens_used"),
            model_used=rag_response["model_used"],
            response_time=response_time,
            sources=rag_response["sources"],
            confidence_score=rag_response["confidence_score"]
        )
        db.add(ai_message)
        await db.commit()
        await db.refresh(ai_message)
        
        # Update conversation timestamp
        conversation.updated_at = datetime.now(timezone.utc)
        await db.commit()
        
        return ChatResponse(
            message_id=ai_message.id,
            content=ai_message.content,
            role=ai_message.role,
            conversation_id=conversation.id,
            sources=rag_response.get("sources", []),
            confidence_score=rag_response.get("confidence_score", 0),
            model_used=rag_response.get("model_used", ""),
            timestamp=rag_response.get("timestamp", datetime.now(timezone.utc).isoformat())
        )
        
    except Exception as e:
        logger.error(f"Error in send_message: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error processing message"
        )


@router.get("/conversations", response_model=List[ConversationResponse])
async def get_conversations(
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's conversations."""
    result = await db.execute(
        select(Conversation).where(
            Conversation.user_id == current_user.id,
            Conversation.is_active == True
        ).order_by(Conversation.updated_at.desc())
    )
    conversations = result.scalars().all()
    
    return conversations


@router.get("/conversations/{conversation_id}/messages", response_model=List[MessageResponse])
async def get_conversation_messages(
    conversation_id: int,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """Get messages from a specific conversation."""
    # Verify conversation belongs to user
    result = await db.execute(
        select(Conversation).where(
            Conversation.id == conversation_id,
            Conversation.user_id == current_user.id
        )
    )
    conversation = result.scalar_one_or_none()
    
    if not conversation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Conversation not found"
        )
    
    # Get messages
    result = await db.execute(
        select(Message).where(
            Message.conversation_id == conversation_id
        ).order_by(Message.created_at.asc())
    )
    messages = result.scalars().all()
    
    return messages


@router.delete("/conversations/{conversation_id}")
async def delete_conversation(
    conversation_id: int,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete a conversation."""
    result = await db.execute(
        select(Conversation).where(
            Conversation.id == conversation_id,
            Conversation.user_id == current_user.id
        )
    )
    conversation = result.scalar_one_or_none()
    
    if not conversation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Conversation not found"
        )
    
    # Soft delete conversation
    conversation.is_active = False
    await db.commit()
    
    return {"message": "Conversation deleted successfully"}


@router.get("/conversations/{conversation_id}", response_model=ConversationResponse)
async def get_conversation(
    conversation_id: int,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """Get a specific conversation."""
    result = await db.execute(
        select(Conversation).where(
            Conversation.id == conversation_id,
            Conversation.user_id == current_user.id
        )
    )
    conversation = result.scalar_one_or_none()
    
    if not conversation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Conversation not found"
        )
    
    return conversation 