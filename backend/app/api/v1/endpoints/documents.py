"""
Document management endpoints for file upload, processing, and retrieval.

Generated on: 2024-12-19T10:30:00Z
Generated by syed
"""

import os
import shutil
from datetime import datetime, timezone
from typing import List, Optional
from pathlib import Path
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel

from app.core.auth import get_current_active_user, get_current_admin_user
from app.core.database import get_db
from app.core.config import settings, validate_file_extension, get_file_size_limit
from app.models.user import User
from app.models.document import Document, DocumentAudience, DocumentStatus
from app.services.rag_service import rag_service
import structlog

logger = structlog.get_logger()
router = APIRouter()


class DocumentResponse(BaseModel):
    """Document response model."""
    id: int
    title: str
    description: Optional[str]
    filename: str
    file_size: int
    file_type: str
    audience: DocumentAudience
    status: DocumentStatus
    version: str
    tags: Optional[str]
    is_processed: bool
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


class DocumentCreate(BaseModel):
    """Document creation request model."""
    title: str
    description: Optional[str] = None
    audience: DocumentAudience = DocumentAudience.BOTH
    tags: Optional[str] = None


class DocumentUpdate(BaseModel):
    """Document update request model."""
    title: Optional[str] = None
    description: Optional[str] = None
    audience: Optional[DocumentAudience] = None
    status: Optional[DocumentStatus] = None
    tags: Optional[str] = None


@router.post("/upload", response_model=DocumentResponse)
async def upload_document(
    file: UploadFile = File(...),
    title: str = Form(...),
    description: Optional[str] = Form(None),
    audience: DocumentAudience = Form(DocumentAudience.BOTH),
    tags: Optional[str] = Form(None),
    current_user: User = Depends(get_current_admin_user),
    db: AsyncSession = Depends(get_db)
):
    """Upload and process a document."""
    try:
        # Validate file
        if not file.filename:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="No file provided"
            )
        
        if not validate_file_extension(file.filename):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid file type. Allowed types: {', '.join(settings.ALLOWED_EXTENSIONS)}"
            )
        
        # Check file size
        file_size = 0
        file_content = b""
        for chunk in file.file:
            file_content += chunk
            file_size += len(chunk)
            if file_size > get_file_size_limit():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="File too large"
                )
        
        # Create upload directory if it doesn't exist
        upload_dir = Path(settings.UPLOAD_DIR)
        upload_dir.mkdir(exist_ok=True)
        
        # Generate unique filename
        file_extension = file.filename.split(".")[-1].lower()
        unique_filename = f"{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}_{file.filename}"
        file_path = upload_dir / unique_filename
        
        # Save file
        with open(file_path, "wb") as buffer:
            buffer.write(file_content)
        
        # Create document record
        document = Document(
            title=title,
            description=description,
            filename=file.filename,
            file_path=str(file_path),
            file_size=file_size,
            file_type=file_extension,
            audience=audience,
            tags=tags,
            uploaded_by=current_user.id
        )
        
        db.add(document)
        await db.commit()
        await db.refresh(document)
        
        # Process document in background (for MVP, we'll do it synchronously)
        try:
            success = await rag_service.process_document(document, str(file_path))
            if success:
                document.is_processed = True
                document.processed_at = datetime.now(timezone.utc)
                document.status = DocumentStatus.PUBLISHED
            else:
                document.status = DocumentStatus.DRAFT
        except Exception as e:
            logger.error(f"Error processing document {document.id}: {str(e)}")
            document.status = DocumentStatus.DRAFT
        
        await db.commit()
        await db.refresh(document)
        
        return document
        
    except Exception as e:
        logger.error(f"Error uploading document: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error uploading document"
        )


@router.get("/", response_model=List[DocumentResponse])
async def get_documents(
    audience: Optional[DocumentAudience] = None,
    status: Optional[DocumentStatus] = None,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """Get documents with optional filtering."""
    query = select(Document)
    
    # Apply filters
    if audience:
        query = query.where(Document.audience == audience)
    if status:
        query = query.where(Document.status == status)
    
    # Non-admin users can only see published documents
    if not current_user.is_admin:
        query = query.where(Document.status == DocumentStatus.PUBLISHED)
    
    # Filter by user role access
    if current_user.is_customer:
        query = query.where(
            Document.audience.in_([DocumentAudience.CUSTOMER, DocumentAudience.BOTH])
        )
    elif current_user.is_field_engineer:
        query = query.where(
            Document.audience.in_([DocumentAudience.FIELD_ENGINEER, DocumentAudience.BOTH])
        )
    
    result = await db.execute(query.order_by(Document.created_at.desc()))
    documents = result.scalars().all()
    
    return documents


@router.get("/{document_id}", response_model=DocumentResponse)
async def get_document(
    document_id: int,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """Get a specific document."""
    result = await db.execute(select(Document).where(Document.id == document_id))
    document = result.scalar_one_or_none()
    
    if not document:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Document not found"
        )
    
    # Check access permissions
    if not current_user.is_admin:
        if document.status != DocumentStatus.PUBLISHED:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Access denied"
            )
        
        if current_user.is_customer and document.audience not in [DocumentAudience.CUSTOMER, DocumentAudience.BOTH]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Access denied"
            )
        
        if current_user.is_field_engineer and document.audience not in [DocumentAudience.FIELD_ENGINEER, DocumentAudience.BOTH]:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Access denied"
            )
    
    return document


@router.put("/{document_id}", response_model=DocumentResponse)
async def update_document(
    document_id: int,
    document_update: DocumentUpdate,
    current_user: User = Depends(get_current_admin_user),
    db: AsyncSession = Depends(get_db)
):
    """Update a document."""
    result = await db.execute(select(Document).where(Document.id == document_id))
    document = result.scalar_one_or_none()
    
    if not document:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Document not found"
        )
    
    # Update fields
    if document_update.title is not None:
        document.title = document_update.title
    if document_update.description is not None:
        document.description = document_update.description
    if document_update.audience is not None:
        document.audience = document_update.audience
    if document_update.status is not None:
        document.status = document_update.status
    if document_update.tags is not None:
        document.tags = document_update.tags
    
    document.updated_at = datetime.now(timezone.utc)
    await db.commit()
    await db.refresh(document)
    
    return document


@router.delete("/{document_id}")
async def delete_document(
    document_id: int,
    current_user: User = Depends(get_current_admin_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete a document."""
    result = await db.execute(select(Document).where(Document.id == document_id))
    document = result.scalar_one_or_none()
    
    if not document:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Document not found"
        )
    
    try:
        # Delete file
        if os.path.exists(document.file_path):
            os.remove(document.file_path)
        
        # Delete from vector database
        await rag_service.delete_document_vectors(document.id)
        
        # Delete from database
        await db.delete(document)
        await db.commit()
        
        return {"message": "Document deleted successfully"}
        
    except Exception as e:
        logger.error(f"Error deleting document {document_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error deleting document"
        )


@router.post("/{document_id}/process")
async def reprocess_document(
    document_id: int,
    current_user: User = Depends(get_current_admin_user),
    db: AsyncSession = Depends(get_db)
):
    """Reprocess a document in the vector database."""
    result = await db.execute(select(Document).where(Document.id == document_id))
    document = result.scalar_one_or_none()
    
    if not document:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Document not found"
        )
    
    try:
        # Delete existing vectors
        await rag_service.delete_document_vectors(document.id)
        
        # Reprocess document
        success = await rag_service.process_document(document, document.file_path)
        
        if success:
            document.is_processed = True
            document.processed_at = datetime.now(timezone.utc)
            document.status = DocumentStatus.PUBLISHED
        else:
            document.is_processed = False
            document.status = DocumentStatus.DRAFT
        
        await db.commit()
        
        return {
            "message": "Document reprocessed successfully" if success else "Document processing failed",
            "success": success
        }
        
    except Exception as e:
        logger.error(f"Error reprocessing document {document_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error reprocessing document"
        ) 