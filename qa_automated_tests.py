#!/usr/bin/env python3
"""
AI Chatbot Platform - Automated QA Test Suite
Generated by syed
Version: 1.0

Professional QA testing automation that covers:
- Functional testing
- Security testing
- Performance testing
- Edge case testing
- Error handling
- Usability testing
"""

import os
import sys
import time
import json
import random
import string
import requests
from datetime import datetime, timezone
from typing import Dict, List, Tuple, Optional
import concurrent.futures
from dataclasses import dataclass
from enum import Enum

# Test Configuration
BASE_URL = os.getenv("BASE_URL", "http://localhost:8000")
FRONTEND_URL = os.getenv("FRONTEND_URL", "http://localhost:3000")
TEST_TIMEOUT = 30
PERFORMANCE_THRESHOLD = {
    "login": 0.5,  # 500ms
    "chat_response": 5.0,  # 5 seconds
    "page_load": 2.0,  # 2 seconds
    "api_response": 1.0  # 1 second
}

class TestStatus(Enum):
    PASS = "PASS"
    FAIL = "FAIL"
    SKIP = "SKIP"
    ERROR = "ERROR"
    WARNING = "WARNING"

class Severity(Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"

@dataclass
class TestResult:
    test_id: str
    test_name: str
    status: TestStatus
    duration: float
    error_message: str = ""
    severity: Severity = Severity.MEDIUM
    screenshots: List[str] = None

class QATestSuite:
    def __init__(self):
        self.results: List[TestResult] = []
        self.session = requests.Session()
        self.tokens = {}
        self.test_data = self._generate_test_data()
        self.start_time = datetime.now(timezone.utc)
        
    def _generate_test_data(self) -> Dict:
        """Generate various test data for comprehensive testing"""
        return {
            "valid_users": {
                "admin": {"username": "admin@demo.com", "password": "admin123"},
                "customer": {"username": "customer@demo.com", "password": "test123"},
                "engineer": {"username": "engineer@demo.com", "password": "test123"}
            },
            "invalid_users": [
                {"username": "", "password": "test123"},
                {"username": "test@test.com", "password": ""},
                {"username": "invalid", "password": "wrong"},
                {"username": "test@test", "password": "123"},
                {"username": "a" * 256, "password": "test123"}
            ],
            "sql_injection_payloads": [
                "' OR '1'='1",
                "'; DROP TABLE users; --",
                "' UNION SELECT * FROM users --",
                "admin'--",
                "' OR 1=1--",
                "\" OR \"\"=\"\"",
                "' OR ''='"
            ],
            "xss_payloads": [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "javascript:alert('XSS')",
                "<iframe src='javascript:alert(\"XSS\")'></iframe>",
                "<input type='text' value='<script>alert(\"XSS\")</script>'>",
                "';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//"
            ],
            "boundary_values": {
                "empty_string": "",
                "single_char": "a",
                "max_length": "a" * 10000,
                "special_chars": "!@#$%^&*()_+-=[]{}|;':\",./<>?",
                "unicode": "ÊµãËØï „ÉÜ„Çπ„Éà —Ç–µ—Å—Ç üöÄüî•üíª",
                "null_bytes": "test\x00test",
                "whitespace": "   \t\n\r   "
            },
            "chat_messages": {
                "normal": [
                    "Hello, I need help with my equipment",
                    "What services does Everi provide?",
                    "Tell me about your payment solutions",
                    "I have a technical issue"
                ],
                "edge_cases": [
                    "",  # Empty message
                    " ",  # Whitespace only
                    "a" * 5000,  # Very long message
                    "üöÄ" * 100,  # Emojis
                    "<script>alert('test')</script>",  # XSS attempt
                    "'; DROP TABLE messages; --",  # SQL injection
                ]
            }
        }
    
    def run_test(self, test_func, test_id: str, test_name: str, 
                 severity: Severity = Severity.MEDIUM) -> TestResult:
        """Execute a single test and record results"""
        start_time = time.time()
        try:
            success, error_msg = test_func()
            duration = time.time() - start_time
            status = TestStatus.PASS if success else TestStatus.FAIL
            result = TestResult(
                test_id=test_id,
                test_name=test_name,
                status=status,
                duration=duration,
                error_message=error_msg,
                severity=severity
            )
        except Exception as e:
            duration = time.time() - start_time
            result = TestResult(
                test_id=test_id,
                test_name=test_name,
                status=TestStatus.ERROR,
                duration=duration,
                error_message=str(e),
                severity=severity
            )
        
        self.results.append(result)
        self._print_result(result)
        return result
    
    def _print_result(self, result: TestResult):
        """Print test result with color coding"""
        colors = {
            TestStatus.PASS: '\033[92m',  # Green
            TestStatus.FAIL: '\033[91m',  # Red
            TestStatus.ERROR: '\033[91m',  # Red
            TestStatus.SKIP: '\033[93m',  # Yellow
            TestStatus.WARNING: '\033[93m'  # Yellow
        }
        
        symbol = {
            TestStatus.PASS: '‚úì',
            TestStatus.FAIL: '‚úó',
            TestStatus.ERROR: '!',
            TestStatus.SKIP: '‚óã',
            TestStatus.WARNING: '‚ö†'
        }
        
        color = colors.get(result.status, '\033[0m')
        print(f"{color}[{symbol[result.status]}] {result.test_id}: {result.test_name} "
              f"({result.duration:.2f}s){'\033[0m'}")
        
        if result.error_message:
            print(f"    ‚îî‚îÄ {result.error_message}")
    
    # ========== AUTHENTICATION TESTS ==========
    
    def test_auth_valid_login(self) -> Tuple[bool, str]:
        """TC002: Test valid login for all user roles"""
        for role, creds in self.test_data["valid_users"].items():
            response = self.session.post(
                f"{BASE_URL}/api/v1/auth/login",
                data=creds,
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            )
            
            if response.status_code != 200:
                return False, f"{role} login failed: {response.status_code}"
            
            data = response.json()
            if "access_token" not in data:
                return False, f"{role} login missing access token"
            
            self.tokens[role] = data["access_token"]
        
        return True, "All roles logged in successfully"
    
    def test_auth_invalid_login(self) -> Tuple[bool, str]:
        """TC003: Test invalid login attempts"""
        for i, invalid_creds in enumerate(self.test_data["invalid_users"]):
            response = self.session.post(
                f"{BASE_URL}/api/v1/auth/login",
                data=invalid_creds,
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            )
            
            if response.status_code == 200:
                return False, f"Invalid login #{i} succeeded unexpectedly"
            
            if response.status_code not in [400, 401, 422]:
                return False, f"Invalid login #{i} returned unexpected status: {response.status_code}"
        
        return True, "All invalid logins properly rejected"
    
    def test_auth_sql_injection(self) -> Tuple[bool, str]:
        """TC020: Test SQL injection in login"""
        for payload in self.test_data["sql_injection_payloads"]:
            response = self.session.post(
                f"{BASE_URL}/api/v1/auth/login",
                data={"username": payload, "password": payload},
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            )
            
            if response.status_code == 500:
                return False, f"SQL injection caused server error: {payload}"
            
            if response.status_code == 200:
                return False, f"SQL injection payload authenticated: {payload}"
        
        return True, "All SQL injection attempts blocked"
    
    def test_auth_session_persistence(self) -> Tuple[bool, str]:
        """TC005: Test JWT session persistence"""
        if "customer" not in self.tokens:
            return False, "No customer token available"
        
        # Test with valid token
        headers = {"Authorization": f"Bearer {self.tokens['customer']}"}
        response = self.session.get(f"{BASE_URL}/api/v1/users/me", headers=headers)
        
        if response.status_code != 200:
            return False, f"Valid token rejected: {response.status_code}"
        
        # Test with invalid token
        headers = {"Authorization": "Bearer invalid_token_12345"}
        response = self.session.get(f"{BASE_URL}/api/v1/users/me", headers=headers)
        
        if response.status_code == 200:
            return False, "Invalid token accepted"
        
        return True, "Session management working correctly"
    
    def test_auth_rate_limiting(self) -> Tuple[bool, str]:
        """TC023: Test rate limiting on login endpoint"""
        # Send 50 rapid requests
        start_time = time.time()
        responses = []
        
        for i in range(50):
            response = self.session.post(
                f"{BASE_URL}/api/v1/auth/login",
                data={"username": f"test{i}@test.com", "password": "wrong"},
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            )
            responses.append(response.status_code)
        
        duration = time.time() - start_time
        
        # Check if any rate limiting occurred
        if 429 in responses:
            return True, f"Rate limiting active after {responses.index(429)} requests"
        
        if duration < 1:  # 50 requests in under 1 second should trigger rate limit
            return False, "No rate limiting detected on rapid requests"
        
        return True, "Request processing appropriately throttled"
    
    # ========== CHAT FUNCTIONALITY TESTS ==========
    
    def test_chat_create_conversation(self) -> Tuple[bool, str]:
        """TC007: Test creating new conversations"""
        if "customer" not in self.tokens:
            return False, "No customer token available"
        
        headers = {"Authorization": f"Bearer {self.tokens['customer']}"}
        
        # Create conversation with title
        response = self.session.post(
            f"{BASE_URL}/api/v1/chat/conversations",
            headers=headers,
            json={"title": f"QA Test - {datetime.now(timezone.utc).isoformat()}"}
        )
        
        if response.status_code != 200:
            return False, f"Failed to create conversation: {response.status_code}"
        
        conv = response.json()
        if "id" not in conv:
            return False, "Conversation missing ID"
        
        self.test_conversation_id = conv["id"]
        
        # Create conversation without title
        response = self.session.post(
            f"{BASE_URL}/api/v1/chat/conversations",
            headers=headers,
            json={}
        )
        
        if response.status_code != 200:
            return False, "Failed to create conversation without title"
        
        return True, "Conversations created successfully"
    
    def test_chat_send_messages(self) -> Tuple[bool, str]:
        """TC008-TC010: Test sending various messages"""
        if "customer" not in self.tokens or not hasattr(self, 'test_conversation_id'):
            return False, "Prerequisites not met"
        
        headers = {"Authorization": f"Bearer {self.tokens['customer']}"}
        conv_id = self.test_conversation_id
        
        # Test normal messages
        for msg in self.test_data["chat_messages"]["normal"][:2]:
            response = self.session.post(
                f"{BASE_URL}/api/v1/chat/conversations/{conv_id}/messages",
                headers=headers,
                json={"content": msg}
            )
            
            if response.status_code != 200:
                return False, f"Failed to send normal message: {response.status_code}"
            
            data = response.json()
            if "response" not in data:
                return False, "No AI response received"
        
        # Test edge cases
        for msg in self.test_data["chat_messages"]["edge_cases"]:
            response = self.session.post(
                f"{BASE_URL}/api/v1/chat/conversations/{conv_id}/messages",
                headers=headers,
                json={"content": msg}
            )
            
            # Empty messages should be rejected
            if msg == "" and response.status_code == 200:
                return False, "Empty message accepted"
            
            # Very long messages should be handled gracefully
            if len(msg) > 5000 and response.status_code == 500:
                return False, "Long message caused server error"
        
        return True, "Message handling working correctly"
    
    def test_chat_xss_prevention(self) -> Tuple[bool, str]:
        """TC021: Test XSS prevention in chat"""
        if "customer" not in self.tokens:
            return False, "No customer token available"
        
        headers = {"Authorization": f"Bearer {self.tokens['customer']}"}
        
        # Create a conversation for XSS testing
        conv_response = self.session.post(
            f"{BASE_URL}/api/v1/chat/conversations",
            headers=headers,
            json={"title": "XSS Test"}
        )
        
        if conv_response.status_code != 200:
            return False, "Failed to create test conversation"
        
        conv_id = conv_response.json()["id"]
        
        # Test XSS payloads
        for payload in self.test_data["xss_payloads"][:3]:
            response = self.session.post(
                f"{BASE_URL}/api/v1/chat/conversations/{conv_id}/messages",
                headers=headers,
                json={"content": payload}
            )
            
            if response.status_code == 200:
                data = response.json()
                # Check if payload is properly escaped in response
                if payload in str(data).replace("\\", ""):
                    return False, f"XSS payload not escaped: {payload}"
        
        return True, "XSS payloads properly handled"
    
    def test_chat_performance(self) -> Tuple[bool, str]:
        """TC026: Test chat response time"""
        if "customer" not in self.tokens:
            return False, "No customer token available"
        
        headers = {"Authorization": f"Bearer {self.tokens['customer']}"}
        
        # Create conversation
        conv_response = self.session.post(
            f"{BASE_URL}/api/v1/chat/conversations",
            headers=headers,
            json={"title": "Performance Test"}
        )
        
        if conv_response.status_code != 200:
            return False, "Failed to create test conversation"
        
        conv_id = conv_response.json()["id"]
        
        # Measure response times
        response_times = []
        
        for i in range(3):
            start_time = time.time()
            response = self.session.post(
                f"{BASE_URL}/api/v1/chat/conversations/{conv_id}/messages",
                headers=headers,
                json={"content": f"Performance test message {i}"}
            )
            response_time = time.time() - start_time
            response_times.append(response_time)
            
            if response.status_code != 200:
                return False, f"Request {i} failed: {response.status_code}"
        
        avg_response_time = sum(response_times) / len(response_times)
        
        if avg_response_time > PERFORMANCE_THRESHOLD["chat_response"]:
            return False, f"Average response time {avg_response_time:.2f}s exceeds threshold"
        
        return True, f"Average response time: {avg_response_time:.2f}s"
    
    # ========== ADMIN FUNCTIONALITY TESTS ==========
    
    def test_admin_user_management(self) -> Tuple[bool, str]:
        """TC014-TC015: Test admin user management"""
        if "admin" not in self.tokens:
            return False, "No admin token available"
        
        headers = {"Authorization": f"Bearer {self.tokens['admin']}"}
        
        # List users
        response = self.session.get(f"{BASE_URL}/api/v1/users", headers=headers)
        
        if response.status_code != 200:
            return False, f"Failed to list users: {response.status_code}"
        
        users = response.json()
        if not isinstance(users, list):
            return False, "Users response not a list"
        
        if len(users) < 3:  # Should have at least our 3 test users
            return False, f"Expected at least 3 users, got {len(users)}"
        
        return True, f"User management working, {len(users)} users found"
    
    def test_admin_document_management(self) -> Tuple[bool, str]:
        """TC017-TC018: Test document management"""
        if "admin" not in self.tokens:
            return False, "No admin token available"
        
        headers = {"Authorization": f"Bearer {self.tokens['admin']}"}
        
        # List documents
        response = self.session.get(f"{BASE_URL}/api/v1/documents", headers=headers)
        
        if response.status_code != 200:
            return False, f"Failed to list documents: {response.status_code}"
        
        documents = response.json()
        if not isinstance(documents, list):
            return False, "Documents response not a list"
        
        return True, f"Document management working, {len(documents)} documents found"
    
    def test_admin_analytics(self) -> Tuple[bool, str]:
        """TC019: Test analytics endpoint"""
        if "admin" not in self.tokens:
            return False, "No admin token available"
        
        headers = {"Authorization": f"Bearer {self.tokens['admin']}"}
        
        response = self.session.get(f"{BASE_URL}/api/v1/admin/analytics", headers=headers)
        
        if response.status_code != 200:
            return False, f"Failed to get analytics: {response.status_code}"
        
        analytics = response.json()
        
        # Verify expected fields
        expected_fields = ["total_users", "total_conversations", "total_messages"]
        for field in expected_fields:
            if field not in analytics:
                return False, f"Analytics missing field: {field}"
        
        return True, "Analytics endpoint working correctly"
    
    # ========== SECURITY TESTS ==========
    
    def test_security_unauthorized_access(self) -> Tuple[bool, str]:
        """TC022: Test unauthorized access to protected endpoints"""
        protected_endpoints = [
            "/api/v1/users/me",
            "/api/v1/users",
            "/api/v1/chat/conversations",
            "/api/v1/documents",
            "/api/v1/admin/analytics"
        ]
        
        for endpoint in protected_endpoints:
            # Test without token
            response = self.session.get(f"{BASE_URL}{endpoint}")
            if response.status_code == 200:
                return False, f"Unprotected access to {endpoint}"
            
            # Test with invalid token
            headers = {"Authorization": "Bearer invalid_token"}
            response = self.session.get(f"{BASE_URL}{endpoint}", headers=headers)
            if response.status_code == 200:
                return False, f"Invalid token accepted for {endpoint}"
        
        return True, "All endpoints properly protected"
    
    def test_security_role_based_access(self) -> Tuple[bool, str]:
        """Test role-based access control"""
        if not all(role in self.tokens for role in ["customer", "admin"]):
            return False, "Required tokens not available"
        
        # Customer should not access admin endpoints
        customer_headers = {"Authorization": f"Bearer {self.tokens['customer']}"}
        response = self.session.get(
            f"{BASE_URL}/api/v1/admin/analytics", 
            headers=customer_headers
        )
        
        if response.status_code == 200:
            return False, "Customer accessed admin endpoint"
        
        # Admin should access admin endpoints
        admin_headers = {"Authorization": f"Bearer {self.tokens['admin']}"}
        response = self.session.get(
            f"{BASE_URL}/api/v1/admin/analytics", 
            headers=admin_headers
        )
        
        if response.status_code != 200:
            return False, "Admin cannot access admin endpoint"
        
        return True, "Role-based access control working"
    
    # ========== PERFORMANCE TESTS ==========
    
    def test_performance_concurrent_users(self) -> Tuple[bool, str]:
        """TC027: Test system under concurrent load"""
        if "customer" not in self.tokens:
            return False, "No customer token available"
        
        def make_request():
            headers = {"Authorization": f"Bearer {self.tokens['customer']}"}
            start = time.time()
            response = self.session.get(f"{BASE_URL}/api/v1/users/me", headers=headers)
            return response.status_code, time.time() - start
        
        # Simulate 20 concurrent requests
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            futures = [executor.submit(make_request) for _ in range(20)]
            results = [f.result() for f in concurrent.futures.as_completed(futures)]
        
        # Analyze results
        status_codes = [r[0] for r in results]
        response_times = [r[1] for r in results]
        
        if not all(code == 200 for code in status_codes):
            failed = len([c for c in status_codes if c != 200])
            return False, f"{failed}/20 requests failed under load"
        
        avg_time = sum(response_times) / len(response_times)
        max_time = max(response_times)
        
        if max_time > 5.0:
            return False, f"Max response time {max_time:.2f}s too high under load"
        
        return True, f"Handled 20 concurrent users, avg response: {avg_time:.2f}s"
    
    # ========== ERROR HANDLING TESTS ==========
    
    def test_error_handling_invalid_json(self) -> Tuple[bool, str]:
        """TC034: Test invalid JSON handling"""
        if "customer" not in self.tokens:
            return False, "No customer token available"
        
        headers = {
            "Authorization": f"Bearer {self.tokens['customer']}",
            "Content-Type": "application/json"
        }
        
        # Send invalid JSON
        response = self.session.post(
            f"{BASE_URL}/api/v1/chat/conversations",
            headers=headers,
            data='{"invalid": json"}'  # Malformed JSON
        )
        
        if response.status_code == 500:
            return False, "Invalid JSON caused server error"
        
        if response.status_code not in [400, 422]:
            return False, f"Unexpected status for invalid JSON: {response.status_code}"
        
        return True, "Invalid JSON handled gracefully"
    
    def test_error_handling_missing_fields(self) -> Tuple[bool, str]:
        """Test missing required fields"""
        # Login without password
        response = self.session.post(
            f"{BASE_URL}/api/v1/auth/login",
            data={"username": "test@test.com"},
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        
        if response.status_code == 500:
            return False, "Missing field caused server error"
        
        if response.status_code == 200:
            return False, "Request succeeded with missing required field"
        
        return True, "Missing fields properly validated"
    
    # ========== MAIN TEST EXECUTION ==========
    
    def run_all_tests(self):
        """Execute all test cases"""
        print("\n" + "="*60)
        print("AI CHATBOT QA TEST SUITE - PROFESSIONAL QA TESTING")
        print("Generated by syed")
        print("="*60 + "\n")
        
        # Check if services are running first
        try:
            response = self.session.get(f"{BASE_URL}/health", timeout=5)
            if response.status_code != 200:
                print("‚ùå Backend service not healthy. Please start services first.")
                return
        except:
            print("‚ùå Cannot connect to backend. Please ensure services are running.")
            return
        
        test_categories = [
            ("AUTHENTICATION TESTS", [
                (self.test_auth_valid_login, "TC002", "Valid Login - All Roles", Severity.CRITICAL),
                (self.test_auth_invalid_login, "TC003", "Invalid Login Attempts", Severity.HIGH),
                (self.test_auth_sql_injection, "TC020", "SQL Injection Prevention", Severity.CRITICAL),
                (self.test_auth_session_persistence, "TC005", "Session Management", Severity.HIGH),
                (self.test_auth_rate_limiting, "TC023", "Rate Limiting", Severity.MEDIUM),
            ]),
            ("CHAT FUNCTIONALITY TESTS", [
                (self.test_chat_create_conversation, "TC007", "Create Conversations", Severity.CRITICAL),
                (self.test_chat_send_messages, "TC008", "Send Messages", Severity.CRITICAL),
                (self.test_chat_xss_prevention, "TC021", "XSS Prevention", Severity.CRITICAL),
                (self.test_chat_performance, "TC026", "Chat Performance", Severity.HIGH),
            ]),
            ("ADMIN FUNCTIONALITY TESTS", [
                (self.test_admin_user_management, "TC014", "User Management", Severity.HIGH),
                (self.test_admin_document_management, "TC017", "Document Management", Severity.HIGH),
                (self.test_admin_analytics, "TC019", "Analytics Dashboard", Severity.MEDIUM),
            ]),
            ("SECURITY TESTS", [
                (self.test_security_unauthorized_access, "TC022", "Unauthorized Access", Severity.CRITICAL),
                (self.test_security_role_based_access, "TC022b", "Role-Based Access", Severity.CRITICAL),
            ]),
            ("PERFORMANCE TESTS", [
                (self.test_performance_concurrent_users, "TC027", "Concurrent Users", Severity.HIGH),
            ]),
            ("ERROR HANDLING TESTS", [
                (self.test_error_handling_invalid_json, "TC034", "Invalid JSON", Severity.MEDIUM),
                (self.test_error_handling_missing_fields, "TC034b", "Missing Fields", Severity.MEDIUM),
            ])
        ]
        
        for category_name, tests in test_categories:
            print(f"\n{category_name}")
            print("-" * len(category_name))
            
            for test_func, test_id, test_name, severity in tests:
                self.run_test(test_func, test_id, test_name, severity)
        
        self.generate_report()
    
    def generate_report(self):
        """Generate comprehensive QA test report"""
        end_time = datetime.now(timezone.utc)
        total_duration = (end_time - self.start_time).total_seconds()
        
        # Calculate statistics
        total_tests = len(self.results)
        passed = len([r for r in self.results if r.status == TestStatus.PASS])
        failed = len([r for r in self.results if r.status == TestStatus.FAIL])
        errors = len([r for r in self.results if r.status == TestStatus.ERROR])
        
        critical_issues = [r for r in self.results 
                          if r.status in [TestStatus.FAIL, TestStatus.ERROR] 
                          and r.severity == Severity.CRITICAL]
        
        print("\n" + "="*60)
        print("QA TEST REPORT SUMMARY")
        print("="*60)
        
        print(f"\nTest Execution Time: {total_duration:.2f} seconds")
        print(f"Total Tests Run: {total_tests}")
        print(f"‚úÖ Passed: {passed} ({passed/total_tests*100:.1f}%)")
        print(f"‚ùå Failed: {failed} ({failed/total_tests*100:.1f}%)")
        print(f"‚ö†Ô∏è  Errors: {errors} ({errors/total_tests*100:.1f}%)")
        
        if critical_issues:
            print(f"\nüö® CRITICAL ISSUES FOUND: {len(critical_issues)}")
            for issue in critical_issues:
                print(f"   - {issue.test_id}: {issue.test_name}")
                print(f"     {issue.error_message}")
        
        # Performance summary
        print("\nüìä PERFORMANCE METRICS:")
        perf_tests = [r for r in self.results if "Performance" in r.test_name]
        for test in perf_tests:
            print(f"   - {test.test_name}: {test.duration:.2f}s")
        
        # Security summary
        security_tests = [r for r in self.results if any(word in r.test_name 
                         for word in ["Security", "SQL", "XSS", "Injection"])]
        security_passed = len([t for t in security_tests if t.status == TestStatus.PASS])
        print(f"\nüîí SECURITY: {security_passed}/{len(security_tests)} tests passed")
        
        # Overall verdict
        print("\n" + "="*60)
        if failed == 0 and errors == 0:
            print("‚úÖ VERDICT: ALL TESTS PASSED - READY FOR PRODUCTION")
        elif len(critical_issues) > 0:
            print("‚ùå VERDICT: CRITICAL ISSUES - NOT READY FOR PRODUCTION")
        elif failed > 0:
            print("‚ö†Ô∏è  VERDICT: SOME TESTS FAILED - REVIEW REQUIRED")
        else:
            print("‚úÖ VERDICT: ACCEPTABLE - MINOR ISSUES ONLY")
        print("="*60)
        
        # Save detailed report
        self._save_detailed_report()
    
    def _save_detailed_report(self):
        """Save detailed test report to file"""
        report_data = {
            "test_run": {
                "start_time": self.start_time.isoformat(),
                "end_time": datetime.now(timezone.utc).isoformat(),
                "duration": (datetime.now(timezone.utc) - self.start_time).total_seconds(),
                "environment": {
                    "backend_url": BASE_URL,
                    "frontend_url": FRONTEND_URL
                }
            },
            "summary": {
                "total_tests": len(self.results),
                "passed": len([r for r in self.results if r.status == TestStatus.PASS]),
                "failed": len([r for r in self.results if r.status == TestStatus.FAIL]),
                "errors": len([r for r in self.results if r.status == TestStatus.ERROR])
            },
            "results": [
                {
                    "test_id": r.test_id,
                    "test_name": r.test_name,
                    "status": r.status.value,
                    "severity": r.severity.value,
                    "duration": r.duration,
                    "error_message": r.error_message
                }
                for r in self.results
            ]
        }
        
        filename = f"qa_test_report_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.json"
        with open(filename, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        print(f"\nüìÑ Detailed report saved to: {filename}")

if __name__ == "__main__":
    # Run the QA test suite
    qa_suite = QATestSuite()
    qa_suite.run_all_tests()